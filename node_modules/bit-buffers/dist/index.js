"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitBuffer = void 0;
var base64_js_1 = __importDefault(require("base64-js"));
var pako_1 = require("pako");
var BITS_PER_BYTE = 8;
var DEFAULT_MIN_LENGTH = 16 * 1024 * BITS_PER_BYTE; // 16KB
var FULL_BYTE = 7;
/**
 * @class
 * BitBuffer
 *
 * A class representing a bit buffer
 */
var BitBuffer = /** @class */ (function () {
    /**
     * @constructor
     * Build a new Bit Buffer
     *
     * @param lengthOrBuffer the length of the buffer in bits, or an existing
     * buffer to use
     */
    function BitBuffer(lengthOrBuffer) {
        if (lengthOrBuffer === void 0) { lengthOrBuffer = DEFAULT_MIN_LENGTH; }
        if (lengthOrBuffer instanceof Buffer) {
            this.buffer = lengthOrBuffer;
        }
        else if (typeof lengthOrBuffer === "number") {
            this.buffer = Buffer.alloc(Math.ceil(lengthOrBuffer / BITS_PER_BYTE));
        }
        else {
            throw new TypeError("Invalid type, must be a number or a Buffer");
        }
    }
    /**
     * Build a new BitBuffer from a compressed bit string
     */
    BitBuffer.fromBitstring = function (input) {
        var buffer = decompress(input);
        return new BitBuffer(buffer);
    };
    /**
     * Built a new BitBuffer from an index array
     */
    BitBuffer.fromIndexArray = function (input, minLength) {
        return input.reduce(function (acc, index) {
            return acc.set(index);
        }, new BitBuffer(minLength));
    };
    Object.defineProperty(BitBuffer.prototype, "length", {
        /**
         * The length of the bit buffer in bits.
         */
        get: function () {
            return this.buffer.byteLength * BITS_PER_BYTE;
        },
        enumerable: false,
        configurable: true
    });
    /**
     *
     * @param offset
     * @param value
     * @returns
     */
    BitBuffer.prototype.write = function (offset, value) {
        if (offset >= this.length) {
            throw new RangeError("Cannot read bits, offset " + offset + " out of bounds.");
        }
        var newBuffer = Buffer.from(this.buffer);
        var currentByte = offset >> 3;
        var byteOffset = offset & FULL_BYTE;
        var byteShift = 7 - byteOffset;
        newBuffer[currentByte] =
            (newBuffer[currentByte] & ~(1 << byteShift)) |
                (((value >>> 0) & 1) << byteShift);
        return new BitBuffer(newBuffer);
    };
    /**
     *
     * @param offset
     * @returns
     *
     * @throws RangeError if the offset is out of bounds
     */
    BitBuffer.prototype.get = function (offset) {
        if (offset >= this.length) {
            throw new RangeError("Cannot read bits, offset " + offset + " out of bounds.");
        }
        var currentByte = offset >> 3;
        var byteOffset = offset & FULL_BYTE;
        var byteShift = 7 - byteOffset;
        return (this.buffer[currentByte] >> byteShift) & 1;
    };
    /**
     * Set a bit to `1` at a given offset.
     *
     * @param offset the location to flip the bit
     * @returns a a copy of this BitBuffer with the bit set
     */
    BitBuffer.prototype.set = function (offset) {
        return this.write(offset, 1);
    };
    /**
     * Set a bit to `0` at a given offset.
     *
     * @param offset the location to flip the bit
     * @returns a a copy of this BitBuffer with the bit unset
     */
    BitBuffer.prototype.unset = function (offset) {
        return this.write(offset, 0);
    };
    /**
     * Test a bit at a given offset. Returns `true` if the bit is set, `false`
     * otherwise
     *
     * @param offset the location to test
     * @returns whether or not the bit is set at the given offset.
     */
    BitBuffer.prototype.test = function (offset) {
        return this.get(offset) === 1;
    };
    /**
     * Generates a compressed bit string from an array of index values
     *
     * @returns a compressed string of bits representing the input array
     */
    BitBuffer.prototype.toBitstring = function () {
        return compress(this.buffer);
    };
    /**
     * Generates an array of indices from the buffer
     *
     * @returns an array of indices
     */
    BitBuffer.prototype.toIndexArray = function () {
        var results = [];
        for (var i = 0; i < this.length; i++) {
            if (this.test(i)) {
                results.push(i);
            }
        }
        return results;
    };
    return BitBuffer;
}());
exports.BitBuffer = BitBuffer;
/**
 * Apply zlib compression with Base64 encoding to a given string or buffer
 *
 * @returns a base64 encoded string containing the zlib compressed input
 */
function compress(input) {
    var deflated = (0, pako_1.deflate)(input);
    return base64_js_1.default.fromByteArray(deflated);
}
/**
 * Given the base64 encoded input array, decode and unzip it to a Buffer
 *
 * @returns a Buffer containing the decoded base64 encoded string
 */
function decompress(input) {
    var decoded = base64_js_1.default.toByteArray(input);
    return Buffer.from((0, pako_1.inflate)(decoded));
}
